# 第2章：项目整体架构设计 - 全局思维

> **本章目标**：学会从全局视角设计系统架构，这决定了项目的可扩展性和可维护性

---

## 💡 关于本章的编程语言

> **重要提示**：从本章开始，文档会同时出现 **Python** 和 **Go** 代码。

### 为什么会有两种语言？

- **Python**：用于讲解概念和设计思路（简单易懂）
- **Go**：NOFX项目的真实实现（实战案例）

### 如果你只会Python？

**完全没问题！** 你可以：

1. ✅ **专注Python部分** - 所有核心概念用Python讲解
2. ✅ **浏览Go代码** - 只看注释和设计思路，不纠结语法
3. ✅ **跳过Go细节** - Go代码不影响理解核心思维
4. ✅ **参考对照表** - 我们会提供Python/Go对照

### 需要学Go吗？

**不需要！** 除非：
- 你将来要用Go开发项目
- 你的工作需要Go
- 你想拓展技能

**现阶段建议**：专注Python，理解项目思维，将来需要时再学Go（会很快）。

### 如果想了解Go语法？

可以阅读 **[Go快速入门](go-basics.md)**（10分钟快速了解）

---

## 🎯 核心概念

### 什么是架构？

**用盖房子类比**：

```
需求分析 = 确定要几个房间、什么功能
           ↓
架构设计 = 画出房子的结构图
           - 承重墙在哪里？
           - 水电管道怎么走？
           - 各个房间如何连接？
           ↓
模块开发 = 具体施工每个房间
```

**软件架构就是**：
- 系统的**骨架和蓝图**
- 定义**核心组件**及其**关系**
- 规划**数据流向**和**通信方式**

### 为什么需要架构设计？

#### ❌ 没有架构的项目

```python
# 所有代码都在一个文件里
def main():
    # 连接数据库
    db = connect_database()

    # 获取数据
    data = fetch_from_api()

    # 处理数据
    result = process_data(data)

    # 显示界面
    show_ui(result)

    # 保存结果
    save_to_db(db, result)
```

**问题**：
- 🔴 想换个数据库？整个文件都要改
- 🔴 想复用处理逻辑？复制粘贴代码
- 🔴 想添加新功能？不知道该写在哪
- 🔴 出了 bug？不知道从哪里查
- 🔴 多人协作？改来改去互相冲突

#### ✅ 有架构的项目

```
┌─────────────────────────────────────────┐
│          用户界面层 (UI)                 │
│  负责：展示数据、接收用户输入             │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│         业务逻辑层 (Logic)               │
│  负责：核心算法、决策、数据处理           │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│         数据访问层 (Data)                │
│  负责：数据库操作、API 调用               │
└─────────────────────────────────────────┘
```

**优势**：
- ✅ 分层清晰，职责明确
- ✅ 修改一层不影响其他层
- ✅ 可以独立测试每一层
- ✅ 团队可以并行开发
- ✅ 容易扩展新功能

### 架构设计的核心原则

| 原则 | 说明 | 举例 |
|------|------|------|
| **单一职责** | 每个模块只做一件事 | 用户认证模块只管登录，不管数据库 |
| **高内聚** | 相关功能放在一起 | 所有交易相关代码在 trader 目录 |
| **低耦合** | 模块间依赖尽量少 | 前端不直接访问数据库，通过 API |
| **可替换** | 组件可以轻松替换 | 换个数据库不影响业务逻辑 |
| **可测试** | 每部分都能独立测试 | 可以单独测试决策引擎 |

---

## 🧠 思维方法

### 方法一：三层架构思维

几乎所有应用都可以分成三层：

```
┌──────────────────────────────────────┐
│   表现层 (Presentation Layer)         │  ← 用户看到的
│   - 网页、APP、命令行界面              │
│   - 负责：展示数据、收集输入            │
└───────────────┬──────────────────────┘
                │
┌───────────────▼──────────────────────┐
│   业务层 (Business Layer)             │  ← 核心逻辑
│   - 业务规则、算法、决策               │
│   - 负责：处理数据、执行业务逻辑        │
└───────────────┬──────────────────────┘
                │
┌───────────────▼──────────────────────┐
│   数据层 (Data Layer)                 │  ← 数据存储
│   - 数据库、文件、外部 API             │
│   - 负责：读写数据、对接外部服务        │
└──────────────────────────────────────┘
```

**判断标准**：
- 如果这段代码是在**显示**东西 → 表现层
- 如果这段代码是在**计算/判断** → 业务层
- 如果这段代码是在**读写数据** → 数据层

**实际例子**：电商网站

| 层级 | 具体实现 | 代码示例 |
|------|----------|----------|
| 表现层 | 商品详情页 | `ProductPage.tsx` |
| 业务层 | 计算优惠价格 | `PriceCalculator.go` |
| 数据层 | 查询商品信息 | `ProductRepository.go` |

### 方法二：前后端分离 vs 单体应用

#### 单体应用架构

```
┌────────────────────────────────┐
│         一个大程序              │
│  ┌──────────────────────────┐ │
│  │   HTML 模板              │ │
│  └──────────────────────────┘ │
│  ┌──────────────────────────┐ │
│  │   业务逻辑               │ │
│  └──────────────────────────┘ │
│  ┌──────────────────────────┐ │
│  │   数据库操作             │ │
│  └──────────────────────────┘ │
└────────────────────────────────┘
         ↓
    一起部署、一起运行
```

**优点**：
- ✅ 简单，一个程序搞定
- ✅ 部署方便
- ✅ 适合小项目

**缺点**：
- ❌ 前后端代码混在一起
- ❌ 难以分工（前端和后端工程师不好协作）
- ❌ 修改界面需要重新部署整个系统
- ❌ 无法单独扩展某一部分

#### 前后端分离架构 ⭐ 推荐

```
┌─────────────────┐          ┌─────────────────┐
│   前端 (React)   │          │   后端 (Go)      │
│                 │          │                 │
│  - 界面渲染      │  HTTP    │  - 业务逻辑      │
│  - 用户交互      │ ◄─────► │  - 数据处理      │
│  - 数据展示      │   API    │  - 数据库操作    │
│                 │          │                 │
└─────────────────┘          └────────┬────────┘
     单独部署                          │
  (静态文件服务器)                     │
                                 ┌────▼────┐
                                 │ 数据库   │
                                 └─────────┘
```

**优点**：
- ✅ 前后端**独立开发**（前端工程师 + 后端工程师并行工作）
- ✅ 前端可以**独立部署**（改个按钮颜色不用重启后端）
- ✅ 后端可以**复用**（一个后端，多个前端：Web + App + 小程序）
- ✅ 技术选型**灵活**（前端用 React，后端用 Go/Python/Java 都行）
- ✅ 可以**单独扩展**（访问量大就多加几台前端服务器）

**缺点**：
- ❌ 复杂度稍高（需要设计 API 接口）
- ❌ 需要处理跨域问题（CORS）
- ❌ 部署两个程序

**如何选择**：
- 小工具、脚本 → 单体应用
- 正式产品、需要扩展 → 前后端分离 ⭐

### 方法三：数据流设计

**核心问题**：数据如何在系统中流动？

#### 单向数据流 ⭐ 推荐

```
用户操作
   ↓
前端发送请求
   ↓
后端接收处理
   ↓
后端返回结果
   ↓
前端更新界面
```

**特点**：
- 流向清晰，容易追踪
- 出问题容易定位
- NOFX 采用这种方式

#### 双向数据流

```
前端 ←─ WebSocket ─→ 后端
     实时双向通信
```

**特点**：
- 实时性强
- 复杂度高
- 适合聊天、股票行情等实时场景

#### NOFX 的数据流

```
┌──────────────┐
│   用户浏览器  │
└──────┬───────┘
       │ 1. HTTP GET /api/account
       ↓
┌──────────────┐
│  Go 后端 API  │
└──────┬───────┘
       │ 2. 查询交易所
       ↓
┌──────────────┐
│ Binance API  │
└──────┬───────┘
       │ 3. 返回账户数据
       ↓
┌──────────────┐
│  Go 后端 API  │
└──────┬───────┘
       │ 4. 返回 JSON
       ↓
┌──────────────┐
│   用户浏览器  │
│  显示余额     │
└──────────────┘
```

### 方法四：画架构图的技巧

#### 第一步：识别核心角色

列出所有参与的"角色"：
- 用户
- 前端
- 后端
- 数据库
- 外部 API（交易所、AI）

#### 第二步：画出关系

用方框和箭头表示：
```
[角色A] ──箭头说明──> [角色B]
```

#### 第三步：标注数据流

箭头上写清楚传递什么数据：
```
[前端] ──账户ID──> [后端] ──API调用──> [交易所]
```

#### 第四步：分层组织

把相同职责的放在一起：
```
┌──────────────────────────────┐
│        前端层                 │
└──────────────────────────────┘
┌──────────────────────────────┐
│        后端层                 │
└──────────────────────────────┘
┌──────────────────────────────┐
│        数据层                 │
└──────────────────────────────┘
```

---

## 📚 NOFX 案例分析

### NOFX 的架构演变过程

#### 阶段 1：最初设想（单体应用）

**假设一开始想法是**：用 Python 写一个脚本

```python
# main.py - 所有代码在一个文件
while True:
    # 获取账户
    account = binance.get_account()

    # 获取市场数据
    klines = binance.get_klines("BTCUSDT")

    # 调用 AI
    decision = deepseek.ask(klines)

    # 执行交易
    if decision == "buy":
        binance.buy("BTCUSDT")

    # 等待 3 分钟
    time.sleep(180)
```

**问题**：
- ❌ 想看监控界面？没有
- ❌ 想同时运行多个 AI？复制粘贴代码
- ❌ 想换交易所？整个文件都要改
- ❌ 想添加日志？到处插代码

**结论**：这不是一个好的架构

---

#### 阶段 2：改进方案（前后端分离）

**重新思考**：

1. **用户需要什么？**
   - 看到实时数据（前端）
   - 自动交易（后端）

2. **哪些部分会经常变化？**
   - 界面样式（前端）
   - 交易策略（后端）

3. **哪些部分需要高性能？**
   - 数据处理（后端用 Go）
   - 界面渲染（前端用 React）

**决策**：采用前后端分离架构

---

### NOFX 最终架构设计

#### 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    用户浏览器 (Browser)                       │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  React 前端应用                                       │  │
│  │  - 竞赛页面 (Competition)                             │  │
│  │  - 详情页面 (TraderDetails)                           │  │
│  │  - 图表组件 (Charts)                                  │  │
│  └─────────────┬────────────────────────────────────────┘  │
└────────────────┼───────────────────────────────────────────┘
                 │ HTTP API 调用
                 │ (JSON 数据交换)
┌────────────────▼───────────────────────────────────────────┐
│              Go 后端服务 (Backend Server)                   │
│  ┌─────────────────────────────────────────────────────┐  │
│  │  API 服务层 (Gin Framework)                          │  │
│  │  - GET /api/account                                  │  │
│  │  - GET /api/positions                                │  │
│  │  - GET /api/competition                              │  │
│  └─────────────┬───────────────────────────────────────┘  │
│                │                                            │
│  ┌─────────────▼───────────────────────────────────────┐  │
│  │  Trader Manager (多交易者管理器)                      │  │
│  │  - 创建和管理多个 AutoTrader 实例                     │  │
│  │  - 协调并发运行                                       │  │
│  └─────────────┬───────────────────────────────────────┘  │
│                │                                            │
│  ┌─────────────▼───────────────────────────────────────┐  │
│  │  AutoTrader 实例 (单个交易者)                         │  │
│  │  ┌──────────────────────────────────────────────┐   │  │
│  │  │  决策循环 (每3分钟)                           │   │  │
│  │  │  1. 获取账户状态                              │   │  │
│  │  │  2. 获取市场数据                              │   │  │
│  │  │  3. AI 决策                                   │   │  │
│  │  │  4. 执行交易                                  │   │  │
│  │  │  5. 记录日志                                  │   │  │
│  │  └──────────────────────────────────────────────┘   │  │
│  └──────┬─────────────┬─────────────┬──────────────────┘  │
└─────────┼─────────────┼─────────────┼─────────────────────┘
          │             │             │
          │             │             │
┌─────────▼──────┐ ┌───▼─────┐ ┌────▼──────────┐
│  Exchange API  │ │ AI API  │ │ 本地文件系统   │
│                │ │         │ │               │
│ - Binance      │ │DeepSeek │ │ decision_logs/│
│ - Hyperliquid  │ │ Qwen    │ │ ├─trader1/   │
│ - Aster        │ │ Custom  │ │ └─trader2/   │
└────────────────┘ └─────────┘ └───────────────┘
```

---

### 架构设计的关键决策

#### 决策 1：为什么用 Go 做后端？

**对比分析**：

| 语言 | 优点 | 缺点 | 适合场景 |
|------|------|------|----------|
| **Python** | 简单易学、库丰富 | 性能较低、并发弱 | 数据分析、脚本 |
| **Node.js** | 前后端同语言、异步强 | 单线程、计算密集型弱 | Web 应用、实时通信 |
| **Go** ⭐ | 高性能、并发强、部署简单 | 学习曲线稍陡 | **高并发、后台服务** |
| **Java** | 生态成熟、企业级 | 笨重、启动慢 | 大型企业应用 |

**NOFX 选择 Go 的原因**：
1. ✅ **并发友好**：多个 Trader 同时运行，Go 的 goroutine 完美支持
2. ✅ **高性能**：处理市场数据、计算指标需要性能
3. ✅ **部署简单**：编译成单个可执行文件，不需要安装运行时
4. ✅ **类型安全**：交易系统不能出错，静态类型帮助检查
5. ✅ **标准库强大**：HTTP、JSON、加密等都有内置支持

**代码示例对比**：

Python（单线程）：
```python
# 只能一个一个运行
for trader in traders:
    trader.run()  # 阻塞，必须等这个完成才能运行下一个
```

Go（并发）：
```go
// 所有 Trader 同时运行
for _, trader := range traders {
    go trader.Run()  // goroutine 并发执行
}
```

---

#### 决策 2：为什么用 React 做前端？

**对比分析**：

| 框架 | 优点 | 缺点 | 适合场景 |
|------|------|------|----------|
| **原生 HTML/JS** | 简单 | 代码混乱、难维护 | 静态页面 |
| **Vue** | 简单易学、中文文档好 | 生态不如 React | 中小型项目 |
| **React** ⭐ | 生态最强、组件化、招人容易 | 学习曲线稍陡 | **复杂交互应用** |
| **Angular** | 功能全面 | 太重、学习成本高 | 大型企业应用 |

**NOFX 选择 React 的原因**：
1. ✅ **组件化**：图表、表格、卡片都是组件，复用方便
2. ✅ **生态强大**：Recharts（图表库）、SWR（数据获取）开箱即用
3. ✅ **性能好**：虚拟 DOM，更新界面快
4. ✅ **社区活跃**：遇到问题容易找到解决方案

**代码示例**：

组件化思维：
```tsx
// 每个部分都是独立组件
<CompetitionPage>
  <Leaderboard traders={traders} />
  <ComparisonChart traders={traders} />
</CompetitionPage>

<TraderDetailsPage>
  <AccountInfo trader={trader} />
  <PositionTable positions={positions} />
  <EquityChart history={history} />
  <DecisionLogs logs={logs} />
</TraderDetailsPage>
```

---

#### 决策 3：前后端如何通信？

**方案对比**：

| 方案 | 优点 | 缺点 | 适合场景 |
|------|------|------|----------|
| **REST API** ⭐ | 简单、标准、易调试 | 不支持实时推送 | 大部分应用 |
| **GraphQL** | 灵活查询、减少请求 | 复杂、学习成本高 | 复杂查询场景 |
| **WebSocket** | 实时双向通信 | 复杂、服务器压力大 | 聊天、游戏 |
| **gRPC** | 高性能 | 浏览器支持差 | 微服务间通信 |

**NOFX 选择 REST API**：
1. ✅ 简单标准（HTTP + JSON）
2. ✅ 浏览器原生支持
3. ✅ 容易调试（用 Postman 测试）
4. ✅ 前端用轮询（SWR 5秒刷新）实现"准实时"

**API 设计示例**：

```
GET  /api/traders                  # 获取所有交易者列表
GET  /api/account?trader_id=xxx    # 获取账户信息
GET  /api/positions?trader_id=xxx  # 获取持仓列表
GET  /api/decisions/latest?trader_id=xxx  # 最新决策
GET  /api/equity-history?trader_id=xxx    # 权益历史
GET  /api/competition              # 竞赛排行榜
```

---

#### 决策 4：数据如何存储？

**方案对比**：

| 方案 | 优点 | 缺点 | 适合场景 |
|------|------|------|----------|
| **MySQL/PostgreSQL** | 功能强大、支持复杂查询 | 需要维护、部署复杂 | 关系型数据 |
| **MongoDB** | 灵活、文档型 | 查询功能弱 | 非结构化数据 |
| **Redis** | 极快 | 内存限制 | 缓存、实时数据 |
| **JSON 文件** ⭐ | 简单、人类可读、无需安装 | 查询慢、并发弱 | **日志、小数据** |

**NOFX 选择 JSON 文件**：
1. ✅ 不需要安装数据库（降低门槛）
2. ✅ 日志可以直接打开查看（调试方便）
3. ✅ 数据量不大（每个 Trader 几千条记录）
4. ✅ 天然备份（文件可以直接复制）

**文件结构**：
```
decision_logs/
├── trader1/
│   ├── 2025-01-15_10-30-00.json
│   ├── 2025-01-15_10-33-00.json
│   └── ...
├── trader2/
│   └── ...
└── performance.db  # 性能统计（内存数据库）
```

---

### NOFX 的模块划分

基于架构设计，NOFX 划分了 8 个核心模块：

```
nofx/
├── config/          # 配置加载模块
│   └── config.go    # 读取 config.json
│
├── trader/          # 交易执行模块
│   ├── interface.go         # Trader 接口定义
│   ├── binance_futures.go   # Binance 实现
│   ├── hyperliquid_trader.go  # Hyperliquid 实现
│   ├── aster_trader.go      # Aster 实现
│   └── auto_trader.go       # 自动交易主控制器
│
├── market/          # 市场数据模块
│   └── data.go      # K线获取、技术指标计算
│
├── pool/            # 币种池模块
│   └── coin_pool.go # 候选币种筛选
│
├── mcp/             # AI 通信模块
│   └── client.go    # DeepSeek/Qwen API 封装
│
├── decision/        # 决策引擎模块
│   └── engine.go    # 提示词构建、JSON 解析
│
├── logger/          # 日志记录模块
│   └── decision_logger.go  # 决策记录、性能追踪
│
├── manager/         # 多交易者管理模块
│   └── trader_manager.go   # 管理多个 AutoTrader
│
├── api/             # API 服务模块
│   └── server.go    # Gin HTTP 服务器
│
└── main.go          # 程序入口
```

**模块职责清晰**：
- 想换交易所？只改 `trader/` 目录
- 想换 AI 模型？只改 `mcp/` 目录
- 想改界面？只改 `web/` 目录
- 想优化决策？只改 `decision/` 目录

---

### 数据流完整路径

#### 场景 1：用户查看账户余额

```
1. 用户打开浏览器 http://localhost:3000
   ↓
2. React 加载 TraderDetailsPage 组件
   ↓
3. useAccount() hook 发起请求:
   GET /api/account?trader_id=trader1
   ↓
4. Go 后端 api/server.go 接收请求
   ↓
5. 调用 traderManager.GetTrader("trader1").GetAccount()
   ↓
6. AutoTrader 调用 trader.GetAccount()
   ↓
7. BinanceFutures.GetAccount() 调用 Binance API
   ↓
8. Binance 返回账户数据
   ↓
9. 层层返回到 api/server.go
   ↓
10. 返回 JSON: { "total_equity": 1200.5, ... }
   ↓
11. React 接收数据，更新界面显示 "1200.5 USDT"
```

#### 场景 2：AI 自动交易决策

```
1. AutoTrader 每 3 分钟执行一次循环
   ↓
2. 调用 trader.GetAccount() 获取账户状态
   ↓
3. 调用 pool.GetCoinPool() 获取候选币种
   ↓
4. 对每个币种调用 market.FetchData() 获取 K 线
   ↓
5. 调用 market.CalculateIndicators() 计算 RSI/MACD
   ↓
6. 调用 logger.GetPerformanceAnalysis() 获取历史表现
   ↓
7. 调用 decision.GetFullDecision() 构建提示词
   ↓
8. decision 引擎调用 mcpClient.Chat() 发送给 AI
   ↓
9. AI 返回决策 JSON
   ↓
10. decision 引擎解析 JSON 成 Decision 结构体
   ↓
11. AutoTrader 根据决策调用 trader.OpenLong()/CloseLong()
   ↓
12. BinanceFutures 调用 Binance API 下单
   ↓
13. 调用 logger.LogDecision() 记录决策和结果
   ↓
14. 保存 JSON 文件到 decision_logs/trader1/xxx.json
```

---

### 架构的可扩展性体现

#### 扩展点 1：添加新交易所

只需 3 步：

```
1. 创建 trader/newexchange_trader.go
   实现 Trader 接口的 5 个方法：
   - GetAccount()
   - GetPositions()
   - OpenLong()
   - OpenShort()
   - CloseLong()
   - CloseShort()

2. 在 config/config.go 添加配置字段
   type TraderConfig struct {
       ...
       NewExchangeAPIKey string
   }

3. 在 manager/trader_manager.go 添加工厂逻辑
   case "newexchange":
       trader = NewNewExchangeTrader(config)
```

**其他代码无需修改**！这就是好架构的威力。

#### 扩展点 2：添加新 AI 模型

只需 2 步：

```
1. 在 mcp/client.go 添加新模型支持
   case "new_ai":
       url = "https://new-ai-api.com/chat"
       model = "new-ai-model-v1"

2. 在 config.json 配置
   {
       "ai_model": "new_ai",
       "new_ai_key": "sk-xxx"
   }
```

#### 扩展点 3：添加新监控页面

只需在前端添加：

```tsx
// web/src/pages/NewPage.tsx
export function NewPage() {
    const { data } = useSWR('/api/new-endpoint', fetcher)
    return <div>新页面</div>
}

// web/src/App.tsx
<Route path="/new" element={<NewPage />} />
```

---

## 💪 实战练习

### 练习 1：画出你的项目架构图（必做）

使用文本画图或者工具（draw.io、excalidraw.com）

**要求**：
1. 标出所有核心组件（前端、后端、数据库、外部 API）
2. 用箭头标注数据流向
3. 写清楚每个组件的职责

**模板**：

```
┌─────────────────┐
│   组件名称       │
│                 │
│  职责：          │
│  - 做什么        │
│  - 用什么技术     │
└────────┬────────┘
         │ 数据流说明
         ↓
┌────────────────┐
│   下一个组件    │
└────────────────┘
```

**示例**（简化版 NOFX）：

```
用户浏览器
   ↓ GET /api/account
Go 后端服务
   ↓ API 调用
Binance 交易所
```

---

### 练习 2：前后端职责划分（必做）

列出你项目的所有功能，标注是前端还是后端负责：

| 功能 | 前端 | 后端 | 理由 |
|------|------|------|------|
| 显示用户列表 | ✅ | | 展示数据 |
| 查询用户数据 | | ✅ | 访问数据库 |
| 表单验证 | ✅ | ✅ | 双重验证 |
| 计算统计数据 | | ✅ | 计算密集 |
| 图表渲染 | ✅ | | 视觉展示 |

**你的项目**：

| 功能 | 前端 | 后端 | 理由 |
|------|------|------|------|
|      |      |      |      |
|      |      |      |      |
|      |      |      |      |

---

### 练习 3：技术选型决策（选做）

为你的项目选择技术栈：

```markdown
## 我的技术选型

### 前端
**选择**：__________（React / Vue / 原生 HTML）

**理由**：
1.
2.
3.

**备选方案**：__________
**为什么不选**：

---

### 后端
**选择**：__________（Go / Python / Node.js / Java）

**理由**：
1.
2.
3.

**备选方案**：__________
**为什么不选**：

---

### 数据存储
**选择**：__________（MySQL / MongoDB / JSON 文件 / Redis）

**理由**：
1.
2.
3.

---

### 前后端通信
**选择**：__________（REST API / GraphQL / WebSocket）

**理由**：
1.
2.
```

---

### 练习 4：模块划分（必做）

将你的项目拆分成 5-10 个模块：

```
my-project/
├── module1/          # 模块名
│   └── 职责：
│   └── 对外接口：
│
├── module2/
│   └── 职责：
│   └── 对外接口：
│
├── module3/
│   └── 职责：
│   └── 对外接口：
│
...
```

**提示**：
- 每个模块做一类事情
- 模块间通过接口通信
- 参考 NOFX 的 8 个模块

---

### 练习 5：数据流路径（选做）

选择一个核心功能，画出完整的数据流路径：

**示例**：用户登录

```
1. 用户在前端输入账号密码
   ↓
2. 前端验证格式（邮箱格式、密码长度）
   ↓
3. 发送 POST /api/login { username, password }
   ↓
4. 后端接收请求
   ↓
5. 查询数据库验证用户
   ↓
6. 生成 JWT Token
   ↓
7. 返回 { token: "xxx", user: {...} }
   ↓
8. 前端存储 token 到 localStorage
   ↓
9. 跳转到主页
```

**你的项目核心功能**：__________

```
1.
   ↓
2.
   ↓
...
```

---

## 🤔 思考题

### 1. 为什么 NOFX 不用 WebSocket 实时推送数据？

<details>
<summary>点击查看答案</summary>

**理由**：
1. **复杂度**：WebSocket 需要维护长连接，服务器压力大
2. **需求不强**：3-5 分钟一次决策，不需要秒级实时性
3. **简单性**：REST + 轮询（SWR 5秒刷新）足够满足需求
4. **可扩展性**：REST 更容易水平扩展（加服务器）

**什么时候用 WebSocket**：
- 聊天应用（必须实时）
- 股票行情（秒级变化）
- 多人协作编辑（实时同步）

NOFX 不属于这些场景。
</details>

---

### 2. 如果要支持 100 个 Trader 同时运行，架构需要调整吗？

<details>
<summary>点击查看答案</summary>

**当前架构的瓶颈**：
- 所有 Trader 在一个进程
- API 调用可能成为瓶颈（交易所限流）

**可能的优化**：
1. **水平扩展**：多台服务器，每台跑部分 Trader
2. **消息队列**：用 Redis/RabbitMQ 解耦 API 调用
3. **数据库**：用 PostgreSQL 替代 JSON 文件
4. **缓存**：用 Redis 缓存市场数据

**但对于 100 个 Trader**：
- 当前架构基本够用（Go 并发能力强）
- 主要瓶颈在外部 API（交易所、AI）
- 可以加限流、错峰调用
</details>

---

### 3. 单体应用什么时候更合适？

<details>
<summary>点击查看答案</summary>

**适合单体应用的场景**：
1. **个人工具/脚本**：就你一个人用
2. **MVP 快速验证**：先上线再说
3. **小型网站**：几个静态页面
4. **内部管理系统**：用户少、需求稳定

**NOFX 为什么不用单体**：
- 需要实时监控（前端）
- 需要多人查看（Web 访问）
- 需要独立部署前后端（迭代快）
- 未来可能扩展（移动端）

**记住**：架构没有绝对好坏，要看场景！
</details>

---

## 📖 本章总结

### 你学到了什么

✅ **核心概念**：
- 架构是系统的骨架和蓝图
- 好架构的 5 大原则（单一职责、高内聚、低耦合、可替换、可测试）

✅ **思维方法**：
- 三层架构思维（表现层、业务层、数据层）
- 前后端分离 vs 单体应用的选择
- 数据流设计
- 画架构图的技巧

✅ **实践技能**：
- 能画出系统架构图
- 能做技术选型决策
- 能划分模块职责
- 能设计数据流路径

✅ **案例收获**：
- NOFX 为什么选择 Go + React
- 如何设计可扩展的模块结构
- 真实项目的架构演变过程

---

### 架构设计检查清单

完成练习后，检查你的架构是否满足：

- [ ] **清晰性**：一眼能看懂系统结构
- [ ] **分层性**：表现层、业务层、数据层职责明确
- [ ] **可扩展**：添加新功能不需要大改
- [ ] **可测试**：每个模块可以独立测试
- [ ] **可维护**：修改一处不影响其他地方
- [ ] **技术合理**：技术选型符合项目需求

---

### 下一步

完成练习后，你应该有：
- ✅ 一份你的项目架构图
- ✅ 明确的技术选型决策
- ✅ 清晰的模块划分方案
- ✅ 核心功能的数据流路径

准备好后，进入 **第 3 章：模块化拆分**，学习如何将架构细化成具体的模块和接口！

---

## 📚 延伸阅读

- 《架构整洁之道》- Robert C. Martin
- 《软件架构设计：程序员向架构师转型必备》
- 《12-Factor App》- 现代 Web 应用架构方法论
- 《微服务设计》- Sam Newman
- NOFX 源码：仔细阅读 `main.go` 了解初始化流程

---

## ❓ FAQ

**Q1：我不懂 Go，能用 Python 做后端吗？**
A：完全可以！架构思想是通用的。Python 用 FastAPI/Flask 也能实现同样架构。

**Q2：架构设计要多详细？**
A：初期粗糙一点没关系，关键是**分层清晰**。详细设计在下一章（模块化拆分）做。

**Q3：架构设计后能改吗？**
A：可以改，但核心架构（前后端分离、分层）最好别频繁变。细节架构（模块划分）可以调整。

**Q4：如何判断架构好坏？**
A：
- 好架构：添加新功能只改一两个文件
- 坏架构：添加新功能到处都要改

**Q5：要学完 Go/React 才能学架构吗？**
A：不用！先理解架构思想，语法可以边做边学。重要的是**知道为什么这样设计**。

---

**🎉 恭喜完成第 2 章！**

现在你已经掌握了**全局架构设计**能力！

记住：**好的架构让你事半功倍，坏的架构让你痛不欲生。**

准备好了告诉我，我们进入第 3 章！💪
